// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: doctor.sql

package db

import (
	"context"
	"database/sql"
)

const countDoctors = `-- name: CountDoctors :one
SELECT COUNT(*) FROM Doctor
`

func (q *Queries) CountDoctors(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDoctors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDoctor = `-- name: CreateDoctor :execresult
INSERT INTO Doctor (
  name, username, password, hospital_id,
  resident_address, checkup_time_id, is_on_leave
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateDoctorParams struct {
	Name            string         `json:"name"`
	Username        string         `json:"username"`
	Password        string         `json:"password"`
	HospitalID      int64          `json:"hospital_id"`
	ResidentAddress sql.NullString `json:"resident_address"`
	CheckupTimeID   int64          `json:"checkup_time_id"`
	IsOnLeave       sql.NullBool   `json:"is_on_leave"`
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createDoctor,
		arg.Name,
		arg.Username,
		arg.Password,
		arg.HospitalID,
		arg.ResidentAddress,
		arg.CheckupTimeID,
		arg.IsOnLeave,
	)
}

const deleteDoctor = `-- name: DeleteDoctor :exec
DELETE FROM Doctor WHERE id = ?
`

func (q *Queries) DeleteDoctor(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDoctor, id)
	return err
}

const getDoctor = `-- name: GetDoctor :one
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor WHERE id = ?
`

func (q *Queries) GetDoctor(ctx context.Context, id int64) (Doctor, error) {
	row := q.db.QueryRowContext(ctx, getDoctor, id)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Password,
		&i.HospitalID,
		&i.ResidentAddress,
		&i.CheckupTimeID,
		&i.IsOnLeave,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorByUsername = `-- name: GetDoctorByUsername :one
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor
WHERE username = ?
`

func (q *Queries) GetDoctorByUsername(ctx context.Context, username string) (Doctor, error) {
	row := q.db.QueryRowContext(ctx, getDoctorByUsername, username)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Password,
		&i.HospitalID,
		&i.ResidentAddress,
		&i.CheckupTimeID,
		&i.IsOnLeave,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDoctors = `-- name: ListDoctors :many
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor ORDER BY id
`

func (q *Queries) ListDoctors(ctx context.Context) ([]Doctor, error) {
	rows, err := q.db.QueryContext(ctx, listDoctors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Password,
			&i.HospitalID,
			&i.ResidentAddress,
			&i.CheckupTimeID,
			&i.IsOnLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoctorsByHospital = `-- name: ListDoctorsByHospital :many
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor
WHERE hospital_id = ?
ORDER BY id
LIMIT ? OFFSET ?
`

type ListDoctorsByHospitalParams struct {
	HospitalID int64 `json:"hospital_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListDoctorsByHospital(ctx context.Context, arg ListDoctorsByHospitalParams) ([]Doctor, error) {
	rows, err := q.db.QueryContext(ctx, listDoctorsByHospital, arg.HospitalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Password,
			&i.HospitalID,
			&i.ResidentAddress,
			&i.CheckupTimeID,
			&i.IsOnLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoctorsOnLeave = `-- name: ListDoctorsOnLeave :many
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor
WHERE is_on_leave = TRUE
ORDER BY id
LIMIT ? OFFSET ?
`

type ListDoctorsOnLeaveParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDoctorsOnLeave(ctx context.Context, arg ListDoctorsOnLeaveParams) ([]Doctor, error) {
	rows, err := q.db.QueryContext(ctx, listDoctorsOnLeave, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Password,
			&i.HospitalID,
			&i.ResidentAddress,
			&i.CheckupTimeID,
			&i.IsOnLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoctorsWithHospital = `-- name: ListDoctorsWithHospital :many
SELECT 
  d.id, d.name, d.username, d.password, d.hospital_id,
  h.name AS hospital_name,
  d.resident_address, d.checkup_time_id, d.is_on_leave,
  d.created_at, d.updated_at
FROM Doctor d
JOIN Hospital h ON d.hospital_id = h.id
ORDER BY d.id
LIMIT ? OFFSET ?
`

type ListDoctorsWithHospitalParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListDoctorsWithHospitalRow struct {
	ID              int64          `json:"id"`
	Name            string         `json:"name"`
	Username        string         `json:"username"`
	Password        string         `json:"password"`
	HospitalID      int64          `json:"hospital_id"`
	HospitalName    string         `json:"hospital_name"`
	ResidentAddress sql.NullString `json:"resident_address"`
	CheckupTimeID   int64          `json:"checkup_time_id"`
	IsOnLeave       sql.NullBool   `json:"is_on_leave"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListDoctorsWithHospital(ctx context.Context, arg ListDoctorsWithHospitalParams) ([]ListDoctorsWithHospitalRow, error) {
	rows, err := q.db.QueryContext(ctx, listDoctorsWithHospital, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDoctorsWithHospitalRow{}
	for rows.Next() {
		var i ListDoctorsWithHospitalRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Password,
			&i.HospitalID,
			&i.HospitalName,
			&i.ResidentAddress,
			&i.CheckupTimeID,
			&i.IsOnLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDoctorsByName = `-- name: SearchDoctorsByName :many
SELECT id, name, username, password, hospital_id, resident_address, checkup_time_id, is_on_leave, created_at, updated_at FROM Doctor
WHERE name LIKE ?
ORDER BY id
LIMIT ? OFFSET ?
`

type SearchDoctorsByNameParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) SearchDoctorsByName(ctx context.Context, arg SearchDoctorsByNameParams) ([]Doctor, error) {
	rows, err := q.db.QueryContext(ctx, searchDoctorsByName, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Password,
			&i.HospitalID,
			&i.ResidentAddress,
			&i.CheckupTimeID,
			&i.IsOnLeave,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDoctor = `-- name: UpdateDoctor :exec
UPDATE Doctor SET
  name = ?,
  username = ?,
  password = ?,
  hospital_id = ?,
  resident_address = ?,
  checkup_time_id = ?,
  is_on_leave = ?
WHERE id = ?
`

type UpdateDoctorParams struct {
	Name            string         `json:"name"`
	Username        string         `json:"username"`
	Password        string         `json:"password"`
	HospitalID      int64          `json:"hospital_id"`
	ResidentAddress sql.NullString `json:"resident_address"`
	CheckupTimeID   int64          `json:"checkup_time_id"`
	IsOnLeave       sql.NullBool   `json:"is_on_leave"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateDoctor(ctx context.Context, arg UpdateDoctorParams) error {
	_, err := q.db.ExecContext(ctx, updateDoctor,
		arg.Name,
		arg.Username,
		arg.Password,
		arg.HospitalID,
		arg.ResidentAddress,
		arg.CheckupTimeID,
		arg.IsOnLeave,
		arg.ID,
	)
	return err
}
